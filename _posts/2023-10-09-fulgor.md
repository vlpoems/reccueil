## Fulgor: A Fast and Compact *k*-mer Index for Large-Scale Matching and Color Queries - 2023

[LINK](https://drops.dagstuhl.de/opus/volltexte/2023/18644/) 

### Authors  
Fan, Jason and Singh, Noor Pratap and Khan, Jamshed and Pibiri, Giulio Ermanno and Patro, Rob

### Résumé

#### En 2 lignes

software d'indexation + pseudoalignement. Dict de kmer avec [SSHash]({% post_url 2023-10-10-sshash %}), unitigs d'un ccdbg triés par couleur donc fast kmer -> unitig -> color. 

#### Préliminaires

*Color*(x) = ensemble des références dans lesquelles le kmer x apparaît. 1 référence = 1 string dans {A, T, C, G}, un génome par exemple.

L'index serait la structure qui permet de trouver *Color*(x) pour chaque kmer x existant. 

Usage de **ccdBG** :\
**de Bruijn Graph** : graphe qui possède des kmers en tant que noeuds et une arête entre 2 noeuds si ces 2 kmers (noeuds) partagent k-1 nucléotides.\
**compacted de Bruijn Graph** : dBG où une suite de plusieurs noeuds consécutifs (sans branchement extérieur) est concaténée pour obtenir un unitig (=1 noeud contenant un string + long qu'un simple kmer).\
**colored compacted de Bruijn Graph** : cdBG où chaque noeud accueille en plus l'info de *Color*(x). (un unitig est monochromatique -> tous les kmers le constituant partagent les memes couleurs)

*ColorID*(u) = couleur de l'unitig u

#### L'index de Fulgor

![figure1](/biblio/assets/fulgor1.png)
A schematic picture of the index described in Section 3, highlighting the interplay between the k-mer dictionary D, the bit-vector B, and the inverted index L. The red arrows show how the index is queried for a k-mer x, assuming that x occurs in unitig u6 and has color C3. The k-mer x is first mapped by D to its unitig u6 via the query *UnitigID*(x) = 6. Then we compute *ColorID*(u6) = *Rank1*(6, B) + 1 = 2 + 1 = 3 and lastly retrieve C3 from L

Dans les faits :
  + 1 ccdBG (unitigs contenant les kmers, chaque unitig possède une couleur unique (pas les + grands possibles car contrainte de la couleur en plus de "non-branching"))
    + Usage de GGCAT pour construire le ccdBG + permet de group by color donc tout est fait en 1 scan de GGCAT

  + 1 dict kmer -> unitig via [SSHash]({% post_url 2023-10-10-sshash %})
    + unitigs stored explicitly (2bits/nt)
    + *UnitigID*(x) -> [1..m] (m = nb_unitigs) répondu rapidement grâce a MPHF sur minimisers
    + opti quand réalisé sur plusieurs kmers successifs (sharing minimiser)

  + 1 dict unitig -> color. Ici, les unitigs sont permutés pour être triés par couleur. Pour check la couleur de l'unitig i, il suffit maintenant de regarder dans un bitvector combien de couleurs ont été vues avant i (*Rank*(B, i)) et ajouter 1. Le bitvector B fonctionne comme tel : 1 si dernier unitig d'une série de même couleur, 0 sinon. (voir figure) B sert donc de struct intermédiaire pour n'avoir à stocker qu'une seule fois une couleur partagée par plusieurs unitigs (dans L)
    + Les couleurs sont compréssées dans L via différentes méthodes selon le rapport \|Ci\| / N (Ci : set de references, N : nb references max)
    + sparse set (ratio<0.25) : diff between consecutive int represented via Elias' code  
    + dense set (ratio>0.75) : same than sparse compression on complementary set
    + other (0.25<ratio<0.75) bit vector encoding (N refs -> N bits, 1 if ref in color else 0)
    + toutes les representations concatenées dans un seul bitvector, dont les positions de départ de couleur sont repertoriées dans un vector trié compressé par elias fano (super small part du bitvector total)
  

  Différentes stratégies de "pseudoalignement" disponibles (=strat de quels kmers choisir pour déterminer la couleur de la query). Certaines sont exhaustives et vont réaliser ce pseudoalignment pour chaque kmer d'une query, d'autres vont utiliser des heuristiques (type "les prochains kmer vont avoir une chance accrues de partager le même unitig donc skip") /False positives\\. tout est implémenté dans fulgor


notes fulgor (apres lecture de [macdbg]({% post_url 2023-10-24-macdbg %})): 
  + dict(kmer -> unitig)
  + unitig -> color (stored compressed in inverted index)
  + sshash aide à garder un ordre efficace au sein des dicts
    - --> cache efficient
  + sort les unitigs pour que ceux ayant les mêmes couleurs soient consécutifs = huge space gain

#### Résultats

Plus rapide et moins d'espace que Themisto (old SOTA). Perd du temps sur les intersections lors du pseudoalignement


